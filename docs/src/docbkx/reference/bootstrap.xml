<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE preface PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="bootstrap">
  <title>Bootstrapping GemFire through the Spring container</title>

  <para>One of the first tasks when using GemFire and Spring is to configure
  the data grid through the IoC container. While this is <ulink
  url="http://community.gemstone.com/display/gemfire/Integrating+GemFire+with+the+Spring+IoC+Container">possible</ulink>
  out of the box, the configuration tends to be verbose and only address basic
  cases. To address this problem, the Spring GemFire project provides several
  classes that enable the configuration of distributed caches or regions to
  support a variety of scenarios with minimal effort.</para>

  <section id="bootstrap:namespace">
  	<title>Using the Spring GemFire Namespace</title>
  	
  	<para>To simplify configuration, SGF provides a dedicated namespace for most of its components. However, one can opt to configure the beans
  	directly through the usual &lt;bean&gt; definition. For more information about XML Schema-based configuration in Spring, see 
  	<ulink url="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/xsd-config.html">this</ulink> appendix in the
  	Spring Framework reference documentation.</para>
  	
  	<para>To use the SGF namespace, one just needs to import it inside the configuration:</para>

 	<programlistingco>
 		<areaspec>
 			<area id="gfe#ns#prefix" coords="4 11"/>
 			<area id="gfe#ns#uri" coords="4 58"/>
 			<area id="gfe#ns#uri#loc" coords="7 119"/>
 			<area id="gfe#ns#example" coords="10 9"/>
 		</areaspec>
 		<programlisting language="xml"><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:gfe="http://www.springframework.org/schema/gemfire"
	xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/gemfire http://www.springframework.org/schema/gemfire/spring-gemfire.xsd">
	<bean id ... >
	
    <gfe:cache ...>
		
</beans>]]></programlisting>
 		
 		<calloutlist>
 			<callout arearefs="gfe#ns#prefix">
 				<para>Spring GemFire namespace prefix. Any name can do but through out the reference documentation, the <literal>gfe</literal> will be used.</para>
 			</callout>
 			<callout arearefs="gfe#ns#uri">
 				<para>The namespace URI.</para>
 			</callout>
 			<callout arearefs="gfe#ns#uri#loc">
 				<para>The namespace URI location. Note that even though the location points to an external address (which exists and is valid), Spring will resolve
 				the schema locally as it is included in the Spring GemFire library.</para>
 			</callout>
 			<callout arearefs="gfe#ns#example">
 				<para>Declaration example for the GemFire namespace. Notice the prefix usage.</para>
 			</callout>
 		</calloutlist>
 	</programlistingco>
 	
 	<para>Once declared, the namespace elements can be declared simply by appending the aforementioned prefix. Note that is possible to change the default namespace,
 	for example from <literal>&lt;beans&gt;</literal> to <literal>&lt;gfe&gt;</literal>. This is useful for configuration composed mainly of GemFire components as
 	it avoids declaring the prefix. To achieve this, simply swap the namespace prefix declaration above:</para>

 	<programlistingco>
 		<areaspec>
 			<area id="gfe#default-ns#prefix" coords="2 64"/>
 			<area id="gfe#default-ns#beans-prefix" coords="3 64"/>
 			<area id="gfe#default-ns#beans-example" coords="9 64"/>
 			<area id="gfe#default-ns#gfe-example" coords="11 64"/>
 		</areaspec>
 		<programlisting language="xml"><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/gemfire"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:beans="http://www.springframework.org/schema/beans"
	xsi:schemaLocation="
	    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
	    http://www.springframework.org/schema/gemfire http://www.springframework.org/schema/gemfire/spring-gemfire.xsd">
	    
    <beans:bean id ... >
	
    <cache ...>
	
</beans>]]></programlisting>
 		
 		<calloutlist>
 			<callout arearefs="gfe#default-ns#prefix">
 				<para>The default namespace declaration for this XML file points to the Spring GemFire namespace.</para>
 			</callout>
 			<callout arearefs="gfe#default-ns#beans-prefix">
 				<para>The beans namespace prefix declaration.</para>
 			</callout>
 			<callout arearefs="gfe#default-ns#beans-example">
 				<para>Bean declaration using the <literal>&lt;beans&gt;</literal> namespace. Notice the prefix.</para>
 			</callout>
 			<callout arearefs="gfe#default-ns#gfe-example">
 				<para>Bean declaration using the <literal>&lt;gfe&gt;</literal> namespace. Notice the lack of prefix (as the default namespace is used).</para>
 			</callout>
 		</calloutlist>
 	</programlistingco>
 	
 	<para>For the remainder of this doc, to improve readability, the XML examples will simply refer to the <literal>&lt;gfe&gt;</literal> namespace
 	without the namespace declaration, where possible.</para>
  </section>
  
  <section id="bootstrap:cache">
  	<title>Configuring the GemFire
    <interfacename>Cache</interfacename></title>

    <para>In order to use the GemFire Fabric, one needs to either create a new
    <interfacename>Cache</interfacename> or connect to an existing one. As in
    the current version of GemFire, there can be only one opened cache per VM
    (or classloader to be technically correct). In most cases the cache is
    created once and then all other consumers connect to it.</para>

    <para>In its simplest form, a cache can be defined in one line:</para>

	<programlisting language="xml"><![CDATA[<gfe:cache />]]></programlisting>
 	
 	<para>The declaration above declares a bean(<literal>CacheFactoryBean</literal>) 
 	for the GemFire Cache, named <literal>gemfire-cache</literal>. All the other SGF components use this
 	naming convention if no name is specified, allowing for very concise configurations. The definition above will try to connect to
    an existing cache and, in case one does not exist, create it. Since no
    additional properties were specified the created cache uses the default
    cache configuration.Especially in environments with opened caches, this basic
    configuration can go a long way.</para>
 	
    <para>For scenarios where the cache needs to be
    configured, the user can pass in a reference the GemFire configuration
    file:</para>

    <programlisting language="xml"><![CDATA[<gfe:cache id="cache-with-xml" cache-xml-location="classpath:cache.xml"/>]]></programlisting>
    
    <para>In this example, if the cache needs to be created, it will use the
    file named <literal>cache.xml</literal> located in the classpath root.
    Only if the cache is created will the configuration file be used.</para> 
    
    <note>
        <para>Note that the configuration makes use of Spring's <ulink
        url="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/resources.html"><interfacename>Resource</interfacename></ulink>
        abstraction to locate the file. This allows various search patterns to
        be used, depending on the running environment or the prefix specified
        (if any) by the value.</para>
      </note>
    <para>  
    In addition to referencing an external configuration file one can
    specify GemFire settings directly through Java
    <classname>Properties</classname>. This can be quite handy when just a few
    settings need to be changed.</para>
    
    <para>To setup properties one can either use the <literal>properties</literal> element inside the <literal>util</literal> namespace
    to declare or load properties files (the latter is recommended for externalizing environment specific settings outside the application
    configuration):</para>

    <programlisting language="xml"><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:gfe="http://www.springframework.org/schema/gemfire"
    xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/gemfire http://www.springframework.org/schema/gemfire/spring-gemfire.xsd
        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">
        
     <gfe:cache id="cache-with-xml" cache-xml-location="classpath:cache.xml" properties-ref="props"/>
	 
     <util:properties id="props" location="classpath:/deployment/env.properties"/>
</beans>]]></programlisting>
    
    <para>Or can use fallback to a <emphasis>raw</emphasis> <literal>&lt;beans&gt;</literal> declaration:</para>
    
    <programlisting language="xml">&lt;bean id="cache-with-props" class="org.springframework.data.gemfire.CacheFactoryBean"&gt;
    &lt;property name="properties"&gt;
        &lt;props&gt;
           &lt;prop key="bind-address"&gt;127.0.0.1&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>

	<para>In this last example, the SGF classes are declared and configured directly without relying on the namespace. As one can tell,
	this approach is a generic one, exposing more of the backing infrastructure.</para>
	
    <para>It is worth pointing out again, that the cache settings apply only
    if the cache needs to be created, there is no opened cache in existence
    otherwise the existing cache will be used and the configuration will
    simply be discarded.</para>
  </section>

  <section id="bootstrap:region">
    <title>Configuring a GemFire <interfacename>Region</interfacename></title>

    <para>Once the <interfacename>Cache</interfacename> is configured, one
    needs to configure one or more <interfacename>Region</interfacename>s to
    interact with the data fabric. SGF allows various region types to be configured and created directly from Spring or 
    in case they are created directly in GemFire, retrieved as such.</para>
    
    <para>For more information about the various region types and their capabilities as well as configuration options, please
    refer to the GemFire Developer's <ulink url="http://www.gemstone.com/documentation">Guide</ulink> and community 
    <ulink url="http://community.gemstone.com/display/gemfire/GemFire+Enterprise">site</ulink>.</para> 

	<section id="bootstrap:region:lookup">
		<title>Using an externaly configured <interfacename>Region</interfacename></title>
		
		<para>For consuming but not creating <interfacename>Region</interfacename>s (for example in case,
		the regions are already configured through GemFire native configuration, the <literal>cache.xml</literal>),
		one can use the <literal>lookup-region</literal> element. Simply declare the target region name the <literal>
		name</literal> attribute; for example to declare a bean definition, named <literal>region-bean</literal>
		for an existing region named <literal>orders</literal> one can use the following definition:</para>
		
		<programlisting language="xml"><![CDATA[<gfe:lookup-region id="region-bean" name="orders"/>]]></programlisting>
		
		<para>If the <literal>name</literal> is not specified, the bean name will be used automatically. The example above
		becomes:</para>
		
		<programlisting language="xml"><![CDATA[<!-- lookup for a region called 'orders' -->
<gfe:lookup-region id="orders"/>]]></programlisting>

		<note><para>If the region does not exist, an initialization exception will be thrown. See the section below
		on how to configure GemFire regions.</para></note>

		<para>Note that in the previous examples, since no cache name was defined, the default SGF naming convention (<literal>gemfire-cache</literal>)
		was used. If that is not an option, one can point to the cache bean through the <literal>cache-ref</literal> attribute:
		</para>
		
		<programlisting language="xml"><![CDATA[<gfe:cache id="cache"/>
		
<gfe:lookup-region id="region-bean" name="orders" cache-ref="cache"/>]]></programlisting>
				
		<para>The <literal>lookup-region</literal> provides a simple way of retrieving existing, pre-configured regions without exposing
		the region semantics or setup infrastructure.</para>
	</section>

	<section id="bootstrap:region:replicate">
		<title>Replicated Region</title>
		
		<para>One of the common region types supported by GemFire is <emphasis>replicated region</emphasis> or <emphasis>replica</emphasis>. In short:</para>
		
		<note><title>What is a replica?</title>
		When a region is configured to be a replicated region, every member that hosts that region stores a copy of the contents of the region locally. 
		Any update to a replicated region is distributed to all copies of the region. [...] When a replica is created, it goes through an initialization stage 
		in which it discovers other replicas and automatically copies all the entries. While one replica is initializing you can still continue to use the other replicas.
		</note>
		
		<para>SGF offers a dedicated element for creating replicas in the form of <literal>replicated-region</literal> element. A minimal declaration looks as follows
		(again, the example will not setup the cache wiring, relying on the SGF namespace naming conventions):</para>

		<programlisting language="xml"><![CDATA[<gfe:replicated-region id="simple-replica" />]]></programlisting>
		
		<para>Here, a replicated region is created (if one doesn't exist already). The name of the region is the same as the bean name (<literal>simple-replica</literal>) and 
		the bean assumes the existence of a GemFire cache named <literal>gemfire-cache</literal>.</para>
		
		<para>When setting a region, it's fairly common to associate various <interfacename>CacheLoader</interfacename>s, <interfacename>CacheListener</interfacename>s and
        <interfacename>CacheWriter</interfacename>s with it. These components can be either referrenced or declared inlined by the region declaration.</para> 
        
        <note><para>
        Following the GemFire recommandations, the namespace allows for each region created multiple listeners but only one
        cache writer and cache loader. This restriction can be relaxed, for advanced usages by using the <literal>beans</literal> declaration (see the next section).
        </para></note>
        
		<para>Below is an example, showing both styles:</para>
        
		<programlisting language="xml"><![CDATA[<gfe:replicated-region id="mixed">
    <gfe:cache-listener>
    	<!-- nested cache listener reference -->
        <ref bean="c-listener"/>
        <!-- nested cache listener declaration -->
        <bean class="some.pkg.SimpleCacheListener"/>
    </gfe:cache-listener>
    <!-- loader reference -->
    <gfe:cache-loader ref="c-loader"/>
    <!-- writer reference -->
    <gfe:cache-writer ref="c-writer"/>
</gfe:replicated-region>]]></programlisting>

		<warning><para>Using <literal>ref</literal> and a nested declaration on <literal>cache-listener</literal>, <literal>cache-loader</literal> or <literal>cache-writer</literal>
		is illegal. The two options are mutually exclusive and using them at the same time, on the same element will throw an exception.</para></warning>
		
		<section id="bootstrap:region:replicate:options">
			<title><literal>replicated-region</literal> Options</title>
			
			<para>The following table offers a quick overview of the most important configuration options names, possible values and short descriptions for each of settings supported by the
			<literal>replicated-region</literal> element. Please see the storage and eviction section for the relevant configuration.</para>
			
        <table id="bootstrap:region:replicate:attrs:table" pgwide="1" align="center">
          <title><![CDATA[replicated-region]]> options</title>
          <tgroup cols="3">
          	<colspec colname="c1"/>
          	<colspec colname="c2"/>
          	<colspec colname="c3"/>
            <thead>
              <row>
                <entry>Name</entry>
                <entry spanname="values">Values</entry>
                <entry align="center">Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>id</entry>
                <entry spanname="values"><emphasis>any valid bean name</emphasis></entry>
                <entry>The id of the region bean definition.</entry>
              </row>
              <row>
                <entry>name</entry>
                <entry spanname="values"><emphasis>any valid region name</emphasis></entry>
                <entry>The name of the region definition. If no specified, it will have the value of the id attribute (that is, the bean name).</entry>
              </row>
              <row>
                <entry>cache-ref</entry>
                <entry spanname="values"><emphasis>GemFire cache bean name</emphasis></entry>
                <entry>The name of the bean defining the GemFire cache (by default 'gemfire-cache').</entry>
              </row>
              <row>
                <entry>cache-listener</entry>
                <entry spanname="values"><emphasis>valid bean name or definition</emphasis></entry>
                <entry>The name or nested bean declaration of a GemFire <interfacename>CacheListener</interfacename>.</entry>
              </row>
              <row>
                <entry>cache-loader</entry>
                <entry spanname="values"><emphasis>valid bean name or definition</emphasis></entry>
                <entry>The name or nested bean declaration of a GemFire <interfacename>CacheLoader</interfacename>.</entry>
              </row>
              <row>
                <entry>cache-writer</entry>
                <entry spanname="values"><emphasis>valid bean name or definition</emphasis></entry>
                <entry>The name or nested bean declaration of a GemFire <interfacename>CacheWriter</interfacename>.</entry>
              </row>
             </tbody>
            </tgroup>
	       </table>        
		</section>		
		
	</section>
	
	<section id="bootstrap:region:partition">
		<title>Partition(ed) Region</title>
		
		<para>Another region type supported out of the box by the SGF namespace, is the partitioned region. To quote again the GemFire docs:</para>
		
		<note><title>What is a partition?</title>
		<para>A partitioned region is a region where data is divided between peer servers hosting the region so that each peer stores a subset of the data. 
		When using a partitioned region, applications are presented with a logical view of the region that looks like a single map containing all of the data in the region. 
		Reads or writes to this map are transparently routed to the peer that hosts the entry that is the target of the operation. [...]
		GemFire divides the domain of hashcodes into buckets. Each bucket is assigned to a specific peer, but may be relocated at any time to another peer in 
		order to improve the utilization of resources across the cluster.</para></note>
		
		<para>A partition can be created by SGF through the <literal>partitioned-region</literal> element. Its configuration options are similar to that of the 
		<literal>replicated-region</literal> plus the partion specific features such as the number of redundant copies, total maximum memory, number of buckets, partition
		resolver and so on.
		Below is a quick example on setting up a partition region with 2 redundant copies:</para>
		
		<programlisting language="xml"><![CDATA[<!-- bean definition named 'distributed-partition' backed by a region named 'redundant' with 2 copies 
and a nested resolver declaration  -->
<gfe:partitioned-region id="distributed-partition" copies="2" total-buckets="4" name="redundant">
    <gfe:partition-resolver>
        <bean class="some.pkg.SimplePartitionResolver"/>
    </gfe:partition-resolver>
</gfe:partitioned-region>]]></programlisting>

		<section id="bootstrap:region:partition:options">
			<title><literal>partitioned-region</literal> Options</title>
			
			<para>The following table offers a quick overview of the most important configuration options names, possible values and short descriptions for each of settings supported by the
			partition element. Please see the storage and eviction section for the relevant configuration.</para>
			
        <table id="bootstrap:region:partition:attrs:table" pgwide="1" align="center">
          <title><![CDATA[partitioned-region]]> options</title>
          <tgroup cols="3">
          	<colspec colname="c1"/>
          	<colspec colname="c2"/>
          	<colspec colname="c3"/>
            <thead>
              <row>
                <entry>Name</entry>
                <entry spanname="values">Values</entry>
                <entry align="center">Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>id</entry>
                <entry spanname="values"><emphasis>any valid bean name</emphasis></entry>
                <entry>The id of the region bean definition.</entry>
              </row>
              <row>
                <entry>name</entry>
                <entry spanname="values"><emphasis>any valid region name</emphasis></entry>
                <entry>The name of the region definition. If no specified, it will have the value of the id attribute (that is, the bean name).</entry>
              </row>
              <row>
                <entry>cache-ref</entry>
                <entry spanname="values"><emphasis>GemFire cache bean name</emphasis></entry>
                <entry>The name of the bean defining the GemFire cache (by default 'gemfire-cache').</entry>
              </row>

              <row>
                <entry>cache-listener</entry>
                <entry spanname="values"><emphasis>valid bean name or definition</emphasis></entry>
                <entry>The name or nested bean declaration of a GemFire <interfacename>CacheListener</interfacename>.</entry>
              </row>
              <row>
                <entry>cache-loader</entry>
                <entry spanname="values"><emphasis>valid bean name or definition</emphasis></entry>
                <entry>The name or nested bean declaration of a GemFire <interfacename>CacheLoader</interfacename>.</entry>
              </row>
              <row>
                <entry>cache-writer</entry>
                <entry spanname="values"><emphasis>valid bean name or definition</emphasis></entry>
                <entry>The name or nested bean declaration of a GemFire <interfacename>CacheWriter</interfacename>.</entry>
              </row>
              
              <row>
                <entry>partition-resolver</entry>
                <entry spanname="values"><emphasis>bean name</emphasis></entry>
                <entry>The name of the partitioned resolver used by this region, for custom partitioning.</entry>
              </row>
              <row>
                <entry>copies</entry>
                <entry spanname="values">0..4</entry>
                <entry>The number of copies for each partition for high-availability. By default, no copies are created meaning there is no
redundancy. Each copy provides extra backup at the expense of extra storages.</entry>
              </row>
              <row>
                <entry>colocated-with</entry>
                <entry spanname="values"><emphasis>valid region name</emphasis></entry>
                <entry>The name of the partitioned region with which this newly created partitioned region is colocated.</entry>
              </row>
              <row>
                <entry>local-max-memory</entry>
                <entry spanname="values"><emphasis>positive integer</emphasis></entry>
                <entry>The maximum amount of memory, in megabytes, to be used by the region in <emphasis>this</emphasis> process.</entry>
              </row>
              <row>
                <entry>total-max-memory</entry>
                <entry spanname="values"><emphasis>any integer value</emphasis></entry>
                <entry>The maximum amount of memory, in megabytes, to be used by the region in <emphasis>all</emphasis> processes.</entry>
              </row>
              <row>
                <entry>recovery-delay</entry>
                <entry spanname="values"><emphasis>any long value</emphasis></entry>
                <entry>The delay in milliseconds that existing members will wait before satisfying redundancy after another member crashes.
-1 (the default) indicates that redundancy will not be recovered after a failure.</entry>
              </row>
              <row>
                <entry>startup-recovery-delay</entry>
                <entry spanname="values"><emphasis>any long value</emphasis></entry>
                <entry>The delay in milliseconds that new members will wait before satisfying redundancy. -1 indicates that adding new members
 will not trigger redundancy recovery. The default is to recover redundancy immediately when a new member is added.</entry>
              </row>
            </tbody>
          </tgroup>
         </table>        
		</section>
	</section>
	
	<section id="bootstrap:region:disk-storage">
		<title>Configurating Disk Storage</title>
		
		<para>GemFire can use disk as a secondary storage for persisting regions or/and overflow (known as data pagination or eviction to disk). SGF allows such options to be configured
		directly from Spring through <literal>disk-store</literal> element available on both <literal>replicated-region</literal> and <literal>partitioned-region</literal>.
		A disk store defines how that particular region can use the disk and how much space it has available. Multiple directories can be defined in a disk store such as in our example below: 
		</para>
		
		<programlisting language="xml"><![CDATA[<gfe:partitioned-region id="partition-data">
    <gfe:disk-store queue-size="50" auto-compact="true" max-oplog-size="10" synchronous-write="false" time-interval="9999">
        <gfe:disk-dir location="/mainbackup/partition" max-size="999"/>
        <gfe:disk-dir location="/backup2/partition" max-size="999"/>
    </gfe:disk-store> 
</gfe:replicated-region>]]></programlisting>
		
		<para>In general, for maximum efficiency, it is recommended that each region that accesses the disk uses a disk store configuration.</para>
		
		<para>
		For the full set of options and their meaning please refer to the <xref linkend="appendix-schema"/>	and GemFire documentation.   
		</para>
		
	</section>	
	
	<section id="bootstrap:region:persistence">
		<title>Data Persistence</title>
		
		<para>Both partitioned and replicated regions can be made persistent. That is:</para>
		
		<note><title>What is region persistence?</title>
		<para>GemFire ensures that all the data you put into a region that is configured for persistence will be written to disk in a way that it can be 
		recovered the next time you create the region. This allows data to be recovered after a machine or process failure or after an orderly shutdown and 
		restart of GemFire.</para>
		</note>
		
		<para>With SGF, to enable persistence, simply set to true the <literal>persistent</literal> attribute on <literal>replicated-region</literal> or 
		<literal>partitioned-region</literal>:</para>
		
		<programlisting language="xml"><![CDATA[<gfe:partitioned-region id="persitent-partition" persistent="true"/>]]></programlisting>

		<important><para>Persistence for partitioned regions is supported from GemFire 6.5 onwards - configuring this option on a previous release will trigger
		an initialization exception.</para></important>
		
		<para>When persisting regions, it is recommended to configure the storage through the <literal>disk-store</literal> element for maximum efficiency.</para>
	</section>
	
	<section id="bootstrap:region:eviction">
		<title>Data Eviction and Overflowing</title>
		
		<para>Based on various constraints, each region can have an eviction policy in place for <literal>evicting</literal> data from memory. Currently, in GemFire
		eviction applies on the least recently used entry (also known as <ulink url="http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used">LRU</ulink>).
		Evicted entries are either destroyed or paged to disk (also known as <emphasis>overflow</emphasis>).</para>
		
		<para>SGF supports all eviction policies (entry count, memory and heap usage) for both <literal>partitioned-region</literal> and <literal>replicated-region</literal>
		through the nested <literal>eviction</literal> element. For example, to configure a partition to overflow to disk if its size is more then 512 MB, one could use
		the following configuration:</para>
		
		<programlisting language="xml"><![CDATA[<gfe:partitioned-region id="overflow-partition">
     <gfe:eviction type="MEMORY_SIZE" threshold="512" action="OVERFLOW_TO_DISK"/>
</gfe:partitioned-region>]]></programlisting>
		
		<important><para>Replicas cannot use a <literal>local destroy</literal> eviction since that would invalidate them. See the GemFire docs for more information.</para></important>
		
		<para>When configuring regions for oveflow, it is recommended to configure the storage through the <literal>disk-store</literal> element for maximum efficiency.</para>
		
		<para>For a detailed description of eviction policies, see the GemFire documentation (such as <ulink url="http://community.gemstone.com/display/gemfire/Data+Eviction">this</ulink>
		page).</para>
	</section>
	
	<section id="bootstrap:region:client">
		<title>Client Region</title>
		
		<para>GemFire supports various deployment topologies for managing and distributing data. The topic is outside the scope of this documentation however to quickly recap, they
		can be categoried in short in: peer-to-peer (p2p), client-server (or super-peer cache network) and wide area cache network (or WAN). In the last two scenarios, it is common
		to declare <emphasis>client</emphasis> regions which connect to a backing cache server (or super peer). SGF offers dedicated support for such configuration through the
		<literal>client-region</literal> and <literal>pool</literal> elements.
		As the name imply, the former defines a client region while the latter connection pools to be used/shared by the various client regions.</para>
		
		<para>Below is a usual configuration for a client region:</para>
		
		<programlisting language="xml"><![CDATA[<!-- client region declaration -->
<gfe:client-region id="complex" pool-name="gemfire-pool">
	<gfe:cache-listener ref="c-listener"/>
</gfe:client-region>
	
<bean id="c-listener" class="some.pkg.SimpleCacheListener"/>

<!-- pool declaration -->	
<gfe:pool id="gemfire-pool" subscription-enabled="false">
	<gfe:locator host="localhost" port="40403"/>
</gfe:pool>]]></programlisting>

		<para>Just as the other region types, <literal>client-region</literal> allows defining <interfacename>CacheListener</interfacename>s. It also relies on the same naming conventions
		in case the region name or the cache are not set explicitely. However, it also requires a connection <literal>pool</literal> to be specified for connecting to the server. Each client
		can have its own pool or they can share the same one.</para>
		
		<para>For a full list of options to set on the client and especially on the pool, please refer to the SGF schema (<xref linkend="appendix-schema"/>) and the GemFire documentation.</para>
		
		<section id="bootstrap:region:client:interests">
			<title>Client Interests</title>
			
			<para>To minimize network traffic, each client can define its own 'interest', pointing out to GemFire, the data it actually needs. In SGF, interests can be defined for each client, both
			key-based and regular-expression-based types being supported; for example:</para>
			
			<programlisting language="xml"><![CDATA[<gfe:client-region id="complex" pool-name="gemfire-pool">
	<gfe:key-interest durable="true" result-policy="KEYS">
	    <bean id="key" class="java.lang.String"/>
	</gfe:key-interest>
	<gfe:regex-interest pattern=".*"/>
</gfe:client-region>]]></programlisting>
		</section>
	</section>
	
	<section id="bootstrap:region:beans:config">
		<title>Advanced Region Configuration</title>
	
		<para>SGF namespaces allow short and easy configuration of the major GemFire regions and associated entities. However, there might be corner cases where the namespaces are not enough, where
		a certain combination or set of attributes needs to be used. For such situations, using directly the SGF <interfacename>FactoryBean</interfacename>s is a possible alternative as it gives
		access to the full set of options at the expense of conciseness.</para>
		
		<para>As a warm up, below are some common configurations, declared through raw <literal>beans</literal> definitions.</para>
		
		<para>A basic configuration looks as follows:</para>
		
		<programlisting language="xml">&lt;bean id="basic" class="org.springframework.data.gemfire.RegionFactoryBean"&gt;
  &lt;property name="cache"&gt;
      &lt;bean class="org.springframework.data.gemfire.CacheFactoryBean"/&gt;
  &lt;/property&gt;
  &lt;property name="name" value="basic"/&gt;
&lt;/bean&gt;</programlisting>

		<para>Notice how the GemFire cache definition has been nested into the declaring region definition. Let's add more regions
		and make the cache a top level bean.</para>
    	<para>Since the region bean definition name is usually the same with that
    of the cache, the <literal>name</literal> property can be omitted (the
    bean name will be used automatically). Additionally by using the name the
    <literal><ulink
    url="http://static.springsource.org/spring/docs/2.5.x/reference/beans.html#beans-p-namespace">p</ulink></literal>
    namespace, the configuration can be simplified even more:</para>

    <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:p="http://www.springframework.org/schema/p"
  xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;
  
    &lt;!-- shared cache across regions --&gt;
    &lt;bean id="cache" class="org.springframework.data.gemfire.CacheFactoryBean"/&gt;

    &lt;!-- region named 'basic' --&gt;
    &lt;bean id="basic" class="org.springframework.data.gemfire.RegionFactoryBean" p:cache-ref="cache"/&gt;

    &lt;!-- region with a name different then the bean definition --&gt;
    &lt;bean id="root-region" class="org.springframework.data.gemfire.RegionFactoryBean" p:cache-ref="cache" p:name="default-region"/&gt;
&lt;/beans&gt;</programlisting>

    <para>It is worth pointing out, that for the vast majority of cases
    configuring the cache loader, listener and writer through the Spring
    container is preferred since the same instances can be reused across
    multiple regions and additionally, the instances themselves can benefit
    from the container's rich feature set:</para>

    <programlisting language="xml">&lt;bean id="cacheLogger" class="org.some.pkg.CacheLogger"/&gt;
&lt;bean id="customized-region" class="org.springframework.data.gemfire.RegionFactoryBean" p:cache-ref="cache"&gt;
  &lt;property name="cacheListeners"&gt;
    &lt;array&gt;
      &lt;ref name="cacheLogger"/&gt;
    &lt;bean class="org.some.other.pkg.SysoutLogger"/&gt;
    &lt;/array&gt;
  &lt;/property&gt;
  &lt;property name="cacheLoader"&gt;&lt;bean class="org.some.pkg.CacheLoad"/&gt;&lt;/property&gt;
  &lt;property name="cacheWriter"&gt;&lt;bean class="org.some.pkg.CacheWrite"/&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="local-region" class="org.springframework.data.gemfire.RegionFactoryBean" p:cache-ref="cache"&gt;
  &lt;property name="cacheListeners" ref="cacheLogger"/&gt;	
&lt;/bean&gt;</programlisting>

      <para>For scenarios where a <emphasis>CacheServer</emphasis> is used and
      <emphasis>clients</emphasis> need to be configured and the namespace is not an option, SGF offers a
      dedicated configuration class named:
      <classname>ClientRegionFactoryBean</classname>. This allows client
      <emphasis>interests</emphasis> to be registered in both key and regex
      form through <classname>Interest</classname> and
      <classname>RegexInterest</classname> classes in the
      <literal>org.springframework.data.gemfire.client</literal> package:</para>

      <programlisting language="xml">&lt;bean id="interested-client" class="org.springframework.data.gemfire.client.ClientRegionFactoryBean" p:cache-ref="cache" p:name="client-region"&gt;
  &lt;property name="interests"&gt;
    &lt;array&gt;
      &lt;!-- key-based interest --&gt;
      &lt;bean class="org.springframework.data.gemfire.client.Interest" p:key="Vlaicu" p:policy="NONE"/&gt;
      &lt;!-- regex-based interest --&gt;
      &lt;bean class="org.springframework.data.gemfire.client.RegexInterest" p:key=".*" p:policy="KEYS" p:durable="true"/&gt;
    &lt;/array&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>
      
      <para>Users that need fine control over a region, can configure it in Spring by using the <literal>attributes</literal> property. To ease declarative configuration in Spring,
      SGF provides two <interfacename>FactoryBean</interfacename>s for creating <interfacename>RegionAttributes</interfacename> and <interfacename>PartitionAttributes</interfacename>,
      namely <classname>RegionAttributesFactory</classname> and <classname>PartitionAttributesFactory</classname>. See below an example of configuring a partitioned region through Spring
      XML:</para>
 
    <programlisting language="xml"><![CDATA[<bean id="partitioned-region" class="org.springframework.data.gemfire.RegionFactoryBean" p:cache-ref="cache">
  <property name="attributes">
    <bean class="org.springframework.data.gemfire.RegionAttributesFactory" p:initial-capacity="1024">
      <property name="partitionAttributes">
        <bean class="org.springframework.data.gemfire.PartitionAttributesFactory" p:redundant-copies="2" p:local-max-memory="512"/>
      </property>
    </bean>
  </property>
</bean>]]>
      </programlisting>
      
      <para>By using the attribute factories above, one can reduce the size of the <literal>cache.xml</literal> or even eliminate it all together.</para>  
    </section>
  </section>
  
  <section id="bootstrap:region:spring:config">
	<title>Advantages of using Spring over GemFire <literal>cache.xml</literal></title>
	<para></para>
  </section>
  
</chapter>